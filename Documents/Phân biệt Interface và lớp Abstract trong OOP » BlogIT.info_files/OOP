// API callback
related_results_labels({"version":"1.0","encoding":"UTF-8","feed":{"xmlns":"http://www.w3.org/2005/Atom","xmlns$openSearch":"http://a9.com/-/spec/opensearchrss/1.0/","xmlns$blogger":"http://schemas.google.com/blogger/2008","xmlns$georss":"http://www.georss.org/georss","xmlns$gd":"http://schemas.google.com/g/2005","xmlns$thr":"http://purl.org/syndication/thread/1.0","id":{"$t":"tag:blogger.com,1999:blog-2532426431791695497"},"updated":{"$t":"2013-03-31T22:51:35.611+07:00"},"category":[{"term":"facebook"},{"term":"Thế giới tâm linh"},{"term":"ghi đĩa"},{"term":"tài liệu IT"},{"term":"Điện thoại"},{"term":"SQL"},{"term":"java"},{"term":"Kho đồ họa"},{"term":"CSS"},{"term":"Kiến thức Network"},{"term":"Lập trình"},{"term":"php"},{"term":"ngày đáng nhớ"},{"term":"Google sites"},{"term":"photoshop"},{"term":"Thủ thuật Blogspot"},{"term":"Fonts"},{"term":"XML"},{"term":"Kiến thức IT"},{"term":"web services"},{"term":"truyện vui"},{"term":"Linux OS"},{"term":"Linh tinh"},{"term":"Tutorials"},{"term":"RMI"},{"term":"ADO.NET"},{"term":"NAT"},{"term":"C#"},{"term":"CCNA"},{"term":"jquery"},{"term":"ảnh vui"},{"term":"Joomla"},{"term":"Bảo mật"},{"term":"CSS3"},{"term":"wpf"},{"term":"OOP"},{"term":"asp.net"},{"term":"vpn"},{"term":"Kho phần mềm"},{"term":"Tin công nghệ"},{"term":"audio online"},{"term":"Windows OS"},{"term":"youngj"},{"term":"SVN"},{"term":"c++"},{"term":"Web-Blog tips"},{"term":"radius"},{"term":"Góc giải trí"}],"title":{"type":"text","$t":"BlogIT.info"},"subtitle":{"type":"html","$t":"SaliproIT Blog | Life is the sharing - Chia sẻ đam mê, trao đổi kinh nghiệm, mở rộng hiểu biết, lưu giữ kiến thức, thủ thuật IT"},"link":[{"rel":"http://schemas.google.com/g/2005#feed","type":"application/atom+xml","href":"http://www.blogit.info/feeds/posts/default"},{"rel":"self","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/-/OOP?alt\u003djson-in-script"},{"rel":"alternate","type":"text/html","href":"http://www.blogit.info/search/label/OOP"},{"rel":"hub","href":"http://pubsubhubbub.appspot.com/"}],"author":[{"name":{"$t":"Salipro Phạm"},"uri":{"$t":"https://plus.google.com/107742437891387520759"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"32","src":"//lh6.googleusercontent.com/-22wkyzzx9zw/AAAAAAAAAAI/AAAAAAAACe4/0BVZTeDIsHs/s512-c/photo.jpg"}}],"generator":{"version":"7.00","uri":"http://www.blogger.com","$t":"Blogger"},"openSearch$totalResults":{"$t":"3"},"openSearch$startIndex":{"$t":"1"},"openSearch$itemsPerPage":{"$t":"25"},"entry":[{"id":{"$t":"tag:blogger.com,1999:blog-2532426431791695497.post-2210262629806332986"},"published":{"$t":"2012-07-22T17:36:00.000+07:00"},"updated":{"$t":"2012-07-22T17:52:58.392+07:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Kiến thức IT"},{"scheme":"http://www.blogger.com/atom/ns#","term":"OOP"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Lập trình"}],"title":{"type":"text","$t":"Tìm hiểu Overriding và Overloading trong OOP"},"content":{"type":"html","$t":"\u003cimg alt\u003d\"Tìm hiểu Overriding và Overloading trong OOP, Difference between method overriding and overloading\" class\u003d\"post-avatar\" src\u003d\"https://lh4.googleusercontent.com/-kMSJbrEgUY8/UAu6hUn7T3I/AAAAAAAACtg/PAsBS0N631M/s187/oop.jpg\" /\u003e\u003cspan class\u003d\"key\"\u003e\u003c/span\u003e \u003cb\u003eDifference between method overriding and overloading.\u003c/b\u003e\u003cbr /\u003eTrong OOP, overriding và overloading là 2 kỹ thuật giúp tạo nên \u003ci\u003eTính đa hình\u003c/i\u003e (Polymorphism), một trong những sức mạnh của lập trình hướng đối tượng. Bài viết này chúng ta sẽ tìm hiểu về khái niệm, cách dùng và tác dụng của 2 kỹ thuật nêu trên.\u003cbr /\u003e\u003ca name\u003d'more'\u003e\u003c/a\u003e\u003cbr /\u003eTrong phạm vi bài viết này chúng ta chỉ để cập đến 2 kỹ thuật này trong Method. Trong lập trình, chúng ta không thể nào khai báo các function (method) trùng tên, nhưng trong OOP chỉ cần áp dụng hai kỹ thuật này, chúng ta hoàn toàn có thể làm được điều đó.\u003cbr /\u003e#bl1 \u003cb\u003eOverriding\u003c/b\u003e\u003cbr /\u003eKhi sử dụng Overriding, bạn đã thay đổi hành vi của method mà nó override. Nói đơn giản là nó đã ghi đè nội dung lên method trước đó. Lưu ý, method này phải được khai báo giống hệt method trước cả đối số và kiểu trả về.\u003cbr /\u003e- Overriding thường được sử dụng trong method ở lớp con.\u003cbr /\u003e#bl3 Một số quy tắc sử dụng phương thức overriding:\u003cbr /\u003e\u003cul\u003e\u003cli\u003eCác phương thức được mô tả static thì không overriden nhưng được mô tả lại.\u003c/li\u003e\u003cli\u003eCác phương thức không kế thừa sẽ không được overriden (hiển nhiên).\u003c/li\u003e\u003cli\u003eChỉ có thể override các phương thức không phải final (java) được khai báo là public hoặc protected.\u003c/li\u003e\u003c/ul\u003e\u003cbr /\u003e#bl1\u0026nbsp;\u003cb\u003eOverloading\u003c/b\u003e\u003cbr /\u003eOverloading đơn giản chỉ để tạo ra các method cùng tên trong cùng một Class. Nhưng các method đó phải khác nhau về \u003ci\u003eđối số đầu vào\u003c/i\u003e (argument) hoặc \u003ci\u003ekiểu trả về\u003c/i\u003e.\u003cbr /\u003e- Các method với kỹ thuật này không ghi đè mà cùng tồn tại song song.\u003cbr /\u003e\u003cbr /\u003e#bl1 \u003cb\u003eVí dụ với C#\u003c/b\u003e\u003cbr /\u003eVới OOP thì C# là một ngôn ngữ thể hiện nó rõ nhất, thích hợp với các bạn mới tìm hiểu về OOP\u003cbr /\u003e#bl2 Kỹ thuật Overriding\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003eclass A\u003cbr /\u003e{\u003cbr /\u003e /* Chỉ những phương thức chứ từ khóa virtual hoặc abstract\u003cbr /\u003e mới cho phép override. */\u003cbr /\u003e public virtual string Hello()\u003cbr /\u003e {\u003cbr /\u003e    return \"Class A\";\u003cbr /\u003e }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eclass B:A\u003cbr /\u003e{\u003cbr /\u003e public override string Hello()\u003cbr /\u003e {\u003cbr /\u003e           retuen \"Class B\";\u003cbr /\u003e }\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e#bl2 Kỹ thuật Overloading\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003eclass A\u003cbr /\u003e{\u003cbr /\u003e public string Hello()\u003cbr /\u003e {\u003cbr /\u003e    return \"No argument\";\u003cbr /\u003e }\u003cbr /\u003e public string Hello(string name)\u003cbr /\u003e {\u003cbr /\u003e    return \"Hello\" + name;\u003cbr /\u003e }\u003cbr /\u003e public int Hello()\u003cbr /\u003e {\u003cbr /\u003e    return 1;\u003cbr /\u003e }\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e\u003cbr /\u003e#bl1 \u003cb\u003eVí dụ với PHP\u003c/b\u003e\u003cbr /\u003eOOP mới được hoàn chỉnh từ PHP5, việc khai báo một số kỹ thuật không rõ ràng như trong C#. Bạn có thể thấy điều đó trong ví dụ bên dưới.\u003cbr /\u003e#bl2 Kỹ thuật Overriding\u003cbr /\u003e\u003cpre class\u003d\"brush: php\"\u003e\u0026lt;?php\u003cbr /\u003e// Trong php ta không cần từ khóa override hay vitual.\u003cbr /\u003eclass A {\u003cbr /\u003e   function Hello() {\u003cbr /\u003e      return \"Class A\";\u003cbr /\u003e   }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eclass B extends A {\u003cbr /\u003e   function Hello() {\u003cbr /\u003e      return \"Class B\";\u003cbr /\u003e   }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e$obj \u003d new B();\u003cbr /\u003eecho $obj-\u0026gt;Hello();\u003cbr /\u003e?\u0026gt;\u003cbr /\u003e\u003c/pre\u003e\u003cbr /\u003e#bl2 Kỹ thuật Overloading\u003cbr /\u003eViệc khai báo function trong PHP chỉ lưu ý đến tên mà không quan tâm đến đối số đầu vào như trong C#, do vậy Overriding không thật sự phát huy khả năng trong PHP.\u003cbr /\u003e\u003cpre class\u003d\"brush: php\"\u003e\u0026lt;?php\u003cbr /\u003eclass A {\u003cbr /\u003e   function Hello() {\u003cbr /\u003e      for ($i \u003d 0; $i \u0026lt; func_num_args(); $i++) {\u003cbr /\u003e        printf(\"Argument %d: %s\\n\", $i, func_get_arg($i));\u003cbr /\u003e    }\u003cbr /\u003e   }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e$obj \u003d new A();\u003cbr /\u003e$obj-\u0026gt;Hello('Linda','John');\u003cbr /\u003e?\u0026gt;\u003cbr /\u003e\u003c/pre\u003eHoặc \u003cbr /\u003e\u003cpre class\u003d\"brush: php\"\u003e\u0026lt;?php\u003cbr /\u003eclass Test\u003cbr /\u003e{\u003cbr /\u003e    // PHP5 bổ sung __call() để hỗ trợ overloading\u003cbr /\u003e    // nhưng nó khá rắc rối! \u003cbr /\u003e    public function __call($nameMethod, $args)\u003cbr /\u003e    {\u003cbr /\u003e        switch($nameMethod) {\u003cbr /\u003e  case \u0026quot;Hello\u0026quot;:\u003cbr /\u003e   switch(count($args)) {\u003cbr /\u003e    case 1:\u003cbr /\u003e     echo \u0026quot;Call: function HelloOne()\u0026quot;.\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; break;\u003cbr /\u003e    default:\u003cbr /\u003e     echo \u0026quot;Call: function Hello()\u0026quot;.\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; break;\u003cbr /\u003e   }\u003cbr /\u003e   break;\u003cbr /\u003e  case \u0026quot;Goodbye\u0026quot;:\u003cbr /\u003e   echo \u0026quot;Call: function Bye()\u0026quot;.\u0026quot;\u0026lt;br\u0026gt;\u0026quot;; break;   \u003cbr /\u003e  default:\u003cbr /\u003e   echo \u0026quot;Nothing\u0026quot;; break;\u003cbr /\u003e  }\u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e$obj \u003d new Test;\u003cbr /\u003e$obj-\u0026gt;Hello(\u0026#039;Linda\u0026#039;);\u003cbr /\u003e$obj-\u0026gt;Hello();\u003cbr /\u003e$obj-\u0026gt;Goodbye();\u003cbr /\u003e$obj-\u0026gt;Goodbye(\u0026#039;Linda\u0026#039;);\u003cbr /\u003e$obj-\u0026gt;Say();\u003cbr /\u003e?\u0026gt;\u003cbr /\u003e\u003c/pre\u003e\u003cdiv class\u003d\"sologan\" itemscope\u003d\"\" itemtype\u003d\"http://data-vocabulary.org/Review\"\u003eCùng \u003cspan itemprop\u003d\"itemreviewed\"\u003eSaliproIT Blog\u003c/span\u003e chia sẻ  \u003cspan itemprop\u003d\"reviewer\"\u003eThế giới công nghệ \u003c/span\u003e  \u003cspan id\u003d\"rate-post\" itemprop\u003d\"rating\"\u003e4.5\u003c/span\u003e sao \u003c/div\u003e"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http://www.blogit.info/feeds/2210262629806332986/comments/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http://www.blogit.info/2012/07/tim-hieu-overriding-va-overloading.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/2210262629806332986"},{"rel":"self","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/2210262629806332986"},{"rel":"alternate","type":"text/html","href":"http://www.blogit.info/2012/07/tim-hieu-overriding-va-overloading.html","title":"Tìm hiểu Overriding và Overloading trong OOP"}],"author":[{"name":{"$t":"Salipro Phạm"},"uri":{"$t":"https://plus.google.com/107742437891387520759"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"32","src":"//lh6.googleusercontent.com/-22wkyzzx9zw/AAAAAAAAAAI/AAAAAAAACe4/0BVZTeDIsHs/s512-c/photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https://lh4.googleusercontent.com/-kMSJbrEgUY8/UAu6hUn7T3I/AAAAAAAACtg/PAsBS0N631M/s72-c/oop.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}},{"id":{"$t":"tag:blogger.com,1999:blog-2532426431791695497.post-4928282651237237621"},"published":{"$t":"2012-07-21T11:46:00.000+07:00"},"updated":{"$t":"2012-07-21T11:46:36.860+07:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Kiến thức IT"},{"scheme":"http://www.blogger.com/atom/ns#","term":"OOP"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Lập trình"}],"title":{"type":"text","$t":"Phân biệt Interface và lớp Abstract trong OOP"},"content":{"type":"html","$t":"\u003cimg alt\u003d\"Interface vs Abstract class in OOP\" class\u003d\"post-avatar\" src\u003d\"https://lh5.googleusercontent.com/-RkUS78ODW6c/UAmlwzZgpbI/AAAAAAAACtQ/jjMrqY_Z0o8/s200/oop.jpg\" /\u003e\u003cspan class\u003d\"key\"\u003e\u003c/span\u003e \u003cb\u003eInterface vs Abstract class in OOP\u003c/b\u003e\u003cbr /\u003eHiện nay mặc dù OOP (Object Oriented Programming) đã rất phổ biến nhưng đa số vẫn còn khá mơ hồ trong việc phân biệt và định nghĩa hai khái niệm lớp Interface và Abstract. Bài viết này chúng ta sẽ tìm hiểu kỹ hơn về khái niệm và sự khác biệt giữa chúng, lưu ý ở đây là Abstract Class chứ không phải là Abstract Method nhé!\u003cbr /\u003e\u003ca name\u003d'more'\u003e\u003c/a\u003e\u003cbr /\u003e#bl1 \u003cb\u003eWhat is an Abstract Class?\u003c/b\u003e\u003cbr /\u003eLớp trừu tượng đơn giản được xem như một class cha cho tất cả các Class có \u003ci\u003ecùng bản chất\u003c/i\u003e. Do đó mỗi lớp dẫn xuất (lớp con) \u003ci\u003echỉ có thể kế thừa từ một lớp trừu tượng\u003c/i\u003e. Bên cạnh đó nó không cho phép tạo instance, nghĩa là sẽ không thể tạo được các đối tượng thuộc lớp đó.\u003cbr /\u003e\u003cbr /\u003e#bl1 \u003cb\u003eWhat is an Interface?\u003c/b\u003e\u003cbr /\u003eLớp này được xem như một mặt nạ cho tất cả các Class \u003ci\u003ecùng cách thức hoạt động\u003c/i\u003e nhưng có thể khác nhau về bản chất. Từ đó lớp dẫn xuất \u003ci\u003ecó thể kế thừa từ nhiều lớp Interface\u003c/i\u003e để bổ sung đầy đủ cách thức hoạt động của mình (đa kế thừa - Multiple inheritance).\u003cbr /\u003e\u003cbr /\u003e\u003cb\u003e\u003ci\u003eVí dụ:\u003c/i\u003e\u003c/b\u003e\u003cbr /\u003e- Abstract class \u003ci\u003eConVat\u003c/i\u003e có các lớp con \u003ci\u003eChim, Ca\u003c/i\u003e.\u003cbr /\u003e- Abstract class \u003ci\u003eMayMoc\u003c/i\u003e có các lớp con \u003ci\u003eMayBay, Thuyen\u003c/i\u003e\u003cbr /\u003e- Interface: \u003ci\u003e iBay, iBoi, iChay.\u003c/i\u003e\u003cbr /\u003e\u003d\u0026gt; \u003ci\u003eMayBay, Chim\u003c/i\u003e sẽ có cùng Interface là \u003ci\u003eiBay\u003c/i\u003e. Rõ ràng mặc dù\u0026nbsp;\u003ci\u003eMayBay, Chim\u003c/i\u003e có cùng cách thức hoạt động là bay nhưng chúng khác nhau về bản chất.\u003cbr /\u003e\u003d\u0026gt;\u0026nbsp;\u003ci\u003eMayBay\u003c/i\u003e cũng\u0026nbsp;có interface là \u003ci\u003eiChay\u003c/i\u003e nhưng \u003ci\u003eChim\u003c/i\u003e không thể nào kế thừa thêm abstract class \u003ci\u003eMayMoc\u003c/i\u003e\u003cbr /\u003e\u003cbr /\u003e#bl1\u0026nbsp;\u003cb\u003eAbstract Class vs Interface\u003c/b\u003e\u003cbr /\u003e#bl2 Nhìn chung cả 2 đều là \"bản thiết kế\" cho các lớp dẫn xuất, do đó chúng\u0026nbsp;\u003ci\u003echỉ chứa các khai báo\u003c/i\u003e\u0026nbsp;Properties và Method mà không quan tâm bên trong thực hiện những gì. Nhưng cụ thể thì Abstract Class là \"bản thiết kế\" cho Class còn Interface là \"bản thiết kế\" cho Method.\u003cbr /\u003e\u003ci\u003e(Ở đây s dùng C# làm ngôn ngữ cho ví dụ)\u003c/i\u003e\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003e//** Ví dụ 1\u003cbr /\u003e//** Abstract class\u003cbr /\u003epublic abstract class Employee\u003cbr /\u003e    {\u003cbr /\u003e        //Khai báo Properties\u003cbr /\u003e        public abstract String ID\u003cbr /\u003e        {\u003cbr /\u003e            get;\u003cbr /\u003e            set;\u003cbr /\u003e        }\u003cbr /\u003e        //Khai báo Method\u003cbr /\u003e        public abstract String Add();\u003cbr /\u003e        public abstract String Update();\u003cbr /\u003e        \u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e//** Interface\u003cbr /\u003epublic interface IEmployee\u003cbr /\u003e    {\u003cbr /\u003e        //Khai báo Properties\u003cbr /\u003e        String ID\u003cbr /\u003e        {\u003cbr /\u003e            get;\u003cbr /\u003e            set;\u003cbr /\u003e        }\u003cbr /\u003e        //Khai báo Method\u003cbr /\u003e        String Add();\u003cbr /\u003e        String Update();\u003cbr /\u003e        \u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e#bl2 Do được xem là bản thiết kế cho toàn Class, nên ngoài những khai báo\u0026nbsp;Properties hoặc Method bắt buộc thì Abstarct class vẫn có thể chứa thêm các Method đã được triển khai hoặc các biến hằng. Ngược lại thì Interface hoàn toàn không thể làm được điều đó.\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003e//** Ví dụ 2\u003cbr /\u003e//** Abstract class\u003cbr /\u003epublic abstract class Employee\u003cbr /\u003e    { \u003cbr /\u003e        //Khai báo biến hằng (field and constant)\u003cbr /\u003e        public String id;\u003cbr /\u003e        public String name;\u003cbr /\u003e\u003cbr /\u003e        //Khai báo Properties\u003cbr /\u003e        public abstract String ID\u003cbr /\u003e        {\u003cbr /\u003e            get;\u003cbr /\u003e            set;\u003cbr /\u003e        }\u003cbr /\u003e\u003cbr /\u003e        //Khai báo Method\u003cbr /\u003e        protected abstract String Add();\u003cbr /\u003e        \u003cbr /\u003e        //Method đã triển khai không dùng abstract\u003cbr /\u003e        public String Update()\u003cbr /\u003e        {\u003cbr /\u003e            return \"Update\";\u003cbr /\u003e        }\u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e//** Interface\u003cbr /\u003epublic interface IEmployee\u003cbr /\u003e    {\u003cbr /\u003e        //Khai báo Properties\u003cbr /\u003e        String ID\u003cbr /\u003e        {\u003cbr /\u003e            get;\u003cbr /\u003e            set;\u003cbr /\u003e        }\u003cbr /\u003e        //Khai báo Method\u003cbr /\u003e        String Add();\u003cbr /\u003e        String Update();\u003cbr /\u003e        \u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e#bl2 Toàn bộ những Method và Properties trong Interface không cần khai báo Access modifier vì mặc định là Public. Abstract class thì phải bắt buộc khai báo (Public, Protected) và bắt buộc có từ khóa \u003cb\u003eabstract \u003c/b\u003etrong các Method và Properties được khai báo trừu tượng.\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003e// Xem ví dụ 2\u003cbr /\u003e\u003c/pre\u003e#bl2 Một điểm khác biệt nữa là ở lớp dẫn xuất của Interface class bắt buộc phải thực hiện toàn bộ những Method và Properties đã khai báo, ngược lại lớp dẫn xuất của Abstract class chỉ cần thực hiện những Method và Properties được khai báo trừu tượng (có từ khóa \u003cb\u003eabstract\u003c/b\u003e)\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003e//** Sử dụng Abstract class và Interface ở ví dụ 2\u003cbr /\u003e//** Lớp dẫn xuất Abstract class\u003cbr /\u003e public class Employee1 : Employee\u003cbr /\u003e {\u003cbr /\u003e    //Không cần khai báo lại biến hằng.\u003cbr /\u003e\u003cbr /\u003e    //Triển khai Properties với từ khóa override\u003cbr /\u003e    public override String ID\u003cbr /\u003e    {\u003cbr /\u003e       get{ return id; }\u003cbr /\u003e       set{ id \u003d value; }\u003cbr /\u003e    }\u003cbr /\u003e\u003cbr /\u003e    //Triển khai Method với access modifier như ở Abstract class.\u003cbr /\u003e    protected override String Add()\u003cbr /\u003e    {\u003cbr /\u003e        return \"Add\";\u003cbr /\u003e    }\u003cbr /\u003e    \u003cbr /\u003e    //Không cần triển khai lại Update() mà chỉ việc sử dụng.\u003cbr /\u003e\u003cbr /\u003e    // Phần triển khai của Employee1\u003cbr /\u003e    ...\u003cbr /\u003e }\u003cbr /\u003e\u003cbr /\u003e//** Lớp dẫn xuất Interface\u003cbr /\u003e public class Employee1 : IEmployee\u003cbr /\u003e {\u003cbr /\u003e     // Biến hằng được định nghĩa ở đây.\u003cbr /\u003e     protected String id;\u003cbr /\u003e     protected String name;\u003cbr /\u003e\u003cbr /\u003e    // Triển khai Properties\u003cbr /\u003e    String ID\u003cbr /\u003e    {\u003cbr /\u003e       get{ return id; }\u003cbr /\u003e       set{ id \u003d value; }\u003cbr /\u003e    }\u003cbr /\u003e    //Triển khai tất cả các Method có ở Interface\u003cbr /\u003e    public String Add()\u003cbr /\u003e    {\u003cbr /\u003e        return \"Add\";\u003cbr /\u003e    }\u003cbr /\u003e    public String Update()\u003cbr /\u003e    {\u003cbr /\u003e        return \"Update\";\u003cbr /\u003e    }\u003cbr /\u003e\u003cbr /\u003e    // Phần triển khai của Employee1\u003cbr /\u003e    ...\u003cbr /\u003e    \u003cbr /\u003e }\u003cbr /\u003e\u003c/pre\u003e#bl2 Ở PHP, sự phân biệt này càng rõ ràng hơn với từ khóa \u003cb\u003eimplement\u003c/b\u003e cho Interface và \u003cb\u003eextend\u003c/b\u003e cho Abstract class. Thực vậy, lớp dẫn xuất của Abstract class chỉ là mở rộng (extend) còn Interface thì buộc là thực hiện (implement) tất cả.\u003cbr /\u003e\u003cbr /\u003e#blsrc Reference: \u003ca target\u003d\"_blank\" href\u003d\"http://www.codeproject.com/Articles/11155/Abstract-Class-versus-Interface\"\u003ewww.codeproject.com\u003c/a\u003e\u003cbr /\u003e\u003cdiv class\u003d\"sologan\" itemscope\u003d\"\" itemtype\u003d\"http://data-vocabulary.org/Review\"\u003eCùng \u003cspan itemprop\u003d\"itemreviewed\"\u003eSaliproIT Blog\u003c/span\u003e chia sẻ  \u003cspan itemprop\u003d\"reviewer\"\u003eThế giới công nghệ \u003c/span\u003e  \u003cspan id\u003d\"rate-post\" itemprop\u003d\"rating\"\u003e5\u003c/span\u003e sao \u003c/div\u003e"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http://www.blogit.info/feeds/4928282651237237621/comments/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http://www.blogit.info/2012/07/phan-biet-interface-va-lop-abstract.html#comment-form","title":"1 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/4928282651237237621"},{"rel":"self","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/4928282651237237621"},{"rel":"alternate","type":"text/html","href":"http://www.blogit.info/2012/07/phan-biet-interface-va-lop-abstract.html","title":"Phân biệt Interface và lớp Abstract trong OOP"}],"author":[{"name":{"$t":"Salipro Phạm"},"uri":{"$t":"https://plus.google.com/107742437891387520759"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"32","src":"//lh6.googleusercontent.com/-22wkyzzx9zw/AAAAAAAAAAI/AAAAAAAACe4/0BVZTeDIsHs/s512-c/photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https://lh5.googleusercontent.com/-RkUS78ODW6c/UAmlwzZgpbI/AAAAAAAACtQ/jjMrqY_Z0o8/s72-c/oop.jpg","height":"72","width":"72"},"thr$total":{"$t":"1"}},{"id":{"$t":"tag:blogger.com,1999:blog-2532426431791695497.post-8847807202563499486"},"published":{"$t":"2011-05-02T14:16:00.000+07:00"},"updated":{"$t":"2012-08-08T11:56:37.281+07:00"},"category":[{"scheme":"http://www.blogger.com/atom/ns#","term":"Kiến thức IT"},{"scheme":"http://www.blogger.com/atom/ns#","term":"C#"},{"scheme":"http://www.blogger.com/atom/ns#","term":"OOP"},{"scheme":"http://www.blogger.com/atom/ns#","term":"Lập trình"}],"title":{"type":"text","$t":"Phân biệt phương thức Virtual - Abstract - C#"},"content":{"type":"html","$t":"\u003cimg alt\u003d\"Title\" class\u003d\"post-avatar\" src\u003d\"https://lh4.googleusercontent.com/-wtbHsSot0JE/TsKx2As5-QI/AAAAAAAABfc/FKcJG8Ew7P8/s260/csharp_thumb.jpg\" /\u003e\u003cspan class\u003d\"key\"\u003e\u003c/span\u003e \u003cb\u003eDifferrence between Virtual and Abstract method.\u003c/b\u003e\u003cbr /\u003e\u003cbr /\u003eTa đã biết các từ khóa \u003cb\u003eVirtual\u003c/b\u003e hoặc \u003cb\u003eAbstract\u003c/b\u003e (bên lớp cơ sở) và \u003cb\u003eOverride\u003c/b\u003e (trên lớp dẫn xuất) hỗ trợ tạo đa hình (Polymorphism) cho các phương thức (Method) của object (1 trong những điểm mạnh của OOP). Phương thức của lớp cha (cơ sở) sử dụng với từ khóa Virtual hoặc Abstract,\u003cbr /\u003e\u003ca name\u003d'more'\u003e\u003c/a\u003etạo phương thức cùng tên ở lớp con (dẫn xuất) với Override..Vậy là ta đã có 1 Method đa hình. Vậy khi nào sử dụng Virtual, khi nào dùng Abstract ở lớp cơ sở (lớp Cha)?\u003cbr /\u003e\u003cbr /\u003e\u003cspan class\u003d\"bullet0\"\u003e\u003c/span\u003eSự khác nhau:\u003cbr /\u003e\u003cbr /\u003e\u003cspan class\u003d\"bullet1\"\u003e\u003c/span\u003eĐiểm đầu tiên là Virtual cho phép lớp Con không nhất thiết phải tạo Override cho method Virtual ở lớp Cha. Ngược lại Abstract thì bắt buộc.\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003eAbstract Class Cha \u003cbr /\u003e{\u003cbr /\u003e....\u003cbr /\u003epublic virtual void AAA() { }\u003cbr /\u003epublic abstract void BBB() ;\u003cbr /\u003e....\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003eClass Con : Cha\u003cbr /\u003e{\u003cbr /\u003e....\u003cbr /\u003epublic override void AAA() { } // có thể không cần hàm này \u003cbr /\u003epublic override void BBB() { } // buộc có.\u003cbr /\u003e....\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e\u003cbr /\u003e\u003cspan class\u003d\"bullet1\"\u003e\u003c/span\u003eThứ 2 là cách khai báo, method Virtual có các hàm bên trong còn Abstract thì tuyệt tối không.\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003epublic virtual void AAA() { code here }\u003cbr /\u003epublic abstract void BBB() ;\u003cbr /\u003e\u003c/pre\u003e\u003cbr /\u003e\u003cspan class\u003d\"bullet1\"\u003e\u003c/span\u003eThứ 3 là method abstract phải nằm trong class abstract như bên dưới.\u003cbr /\u003e\u003cpre class\u003d\"brush: csharp\"\u003eAbstract Class Cha \u003cbr /\u003e{\u003cbr /\u003epublic abstract void BBB() ;\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e"},"link":[{"rel":"replies","type":"application/atom+xml","href":"http://www.blogit.info/feeds/8847807202563499486/comments/default","title":"Post Comments"},{"rel":"replies","type":"text/html","href":"http://www.blogit.info/2011/05/phan-biet-phuong-thuc-virtual-abstract.html#comment-form","title":"0 Comments"},{"rel":"edit","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/8847807202563499486"},{"rel":"self","type":"application/atom+xml","href":"http://www.blogger.com/feeds/2532426431791695497/posts/default/8847807202563499486"},{"rel":"alternate","type":"text/html","href":"http://www.blogit.info/2011/05/phan-biet-phuong-thuc-virtual-abstract.html","title":"Phân biệt phương thức Virtual - Abstract - C#"}],"author":[{"name":{"$t":"Salipro Phạm"},"uri":{"$t":"https://plus.google.com/107742437891387520759"},"email":{"$t":"noreply@blogger.com"},"gd$image":{"rel":"http://schemas.google.com/g/2005#thumbnail","width":"32","height":"32","src":"//lh6.googleusercontent.com/-22wkyzzx9zw/AAAAAAAAAAI/AAAAAAAACe4/0BVZTeDIsHs/s512-c/photo.jpg"}}],"media$thumbnail":{"xmlns$media":"http://search.yahoo.com/mrss/","url":"https://lh4.googleusercontent.com/-wtbHsSot0JE/TsKx2As5-QI/AAAAAAAABfc/FKcJG8Ew7P8/s72-c/csharp_thumb.jpg","height":"72","width":"72"},"thr$total":{"$t":"0"}}]}});